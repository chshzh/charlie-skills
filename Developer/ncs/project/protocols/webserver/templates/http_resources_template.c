/*
 * Copyright (c) 2024 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/**
 * @file http_resources_template.c
 * @brief Static Web Server HTTP Resource Definitions
 * 
 * This template demonstrates how to create a complete HTTP server with:
 * - Static resources (HTML, CSS, JS, images) served with gzip compression
 * - Dynamic REST API endpoints with JSON payloads
 * - WebSocket for real-time bidirectional communication
 * 
 * ARCHITECTURE:
 * - Uses Zephyr's built-in HTTP server framework
 * - Resources defined with HTTP_RESOURCE_DEFINE() macros
 * - Static resources embedded as .gz.inc files (generated by CMake)
 * - Dynamic resources use callbacks for runtime data
 * 
 * BASED ON:
 * Nordic Thingy91x Suitcase Demo - Production-proven implementation
 * 
 * USAGE:
 * 1. Add static web files to static_web_resources/ directory
 * 2. Update CMakeLists.txt to generate .gz.inc files
 * 3. Define resources below
 * 4. Implement dynamic resource callbacks
 * 5. Build with overlay-static-webserver.conf
 */

#include "http_resources_template.h"
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/net/http/server.h>
#include <zephyr/net/http/service.h>
#include <zephyr/data/json.h>

LOG_MODULE_REGISTER(http_resources, CONFIG_HTTP_RESOURCES_LOG_LEVEL);

/*******************************************************************************
 * HTTP Service Definition
 ******************************************************************************/

/**
 * HTTP service configuration
 * 
 * Parameters:
 * - name: Service identifier
 * - host: NULL for any interface
 * - port: Pointer to port number (typically 80 for HTTP, 443 for HTTPS)
 * - detail: Concurrent connections limit
 * - backlog: Listen backlog
 * - user_data: Custom data pointer
 */
static uint16_t http_service_port = CONFIG_HTTP_SERVER_SERVICE_PORT;
HTTP_SERVICE_DEFINE(web_service, NULL, &http_service_port, 10, 10, NULL);

/*******************************************************************************
 * Static Resources (Embedded Files)
 ******************************************************************************/

/**
 * STATIC RESOURCE PATTERN:
 * 
 * 1. Include gzip-compressed file (generated by CMake)
 * 2. Define resource detail structure
 * 3. Register resource with HTTP_RESOURCE_DEFINE()
 */

////////////////// Index HTML (Main Page) //////////////////

/* Include the gzip-compressed HTML file */
static const uint8_t index_html_gz[] = {
#include "index.html.gz.inc"
};

/* Define resource metadata */
struct http_resource_detail_static index_html_resource_detail = {
	.common = {
		.type = HTTP_RESOURCE_TYPE_STATIC,
		.bitmask_of_supported_http_methods = BIT(HTTP_GET),
		.content_encoding = "gzip",         /* Tell browser it's gzipped */
		.content_type = "text/html",        /* MIME type */
	},
	.static_data = index_html_gz,
	.static_data_len = sizeof(index_html_gz),
};

/* Register resource at "/" URL path */
HTTP_RESOURCE_DEFINE(index_html_resource, web_service, "/", &index_html_resource_detail);

////////////////// JavaScript //////////////////

static const uint8_t main_js_gz[] = {
#include "main.js.gz.inc"
};

struct http_resource_detail_static main_js_resource_detail = {
	.common = {
		.type = HTTP_RESOURCE_TYPE_STATIC,
		.bitmask_of_supported_http_methods = BIT(HTTP_GET),
		.content_encoding = "gzip",
		.content_type = "application/javascript",
	},
	.static_data = main_js_gz,
	.static_data_len = sizeof(main_js_gz),
};

HTTP_RESOURCE_DEFINE(main_js_resource, web_service, "/main.js", &main_js_resource_detail);

////////////////// CSS Stylesheet //////////////////

static const uint8_t styles_css_gz[] = {
#include "styles.css.gz.inc"
};

struct http_resource_detail_static styles_css_resource_detail = {
	.common = {
		.type = HTTP_RESOURCE_TYPE_STATIC,
		.bitmask_of_supported_http_methods = BIT(HTTP_GET),
		.content_encoding = "gzip",
		.content_type = "text/css",
	},
	.static_data = styles_css_gz,
	.static_data_len = sizeof(styles_css_gz),
};

HTTP_RESOURCE_DEFINE(styles_css_resource, web_service, "/styles.css", &styles_css_resource_detail);

////////////////// SVG Image //////////////////

static const uint8_t logo_svg_gz[] = {
#include "logo.svg.gz.inc"
};

struct http_resource_detail_static logo_svg_resource_detail = {
	.common = {
		.type = HTTP_RESOURCE_TYPE_STATIC,
		.bitmask_of_supported_http_methods = BIT(HTTP_GET),
		.content_encoding = "gzip",
		.content_type = "image/svg+xml",
	},
	.static_data = logo_svg_gz,
	.static_data_len = sizeof(logo_svg_gz),
};

HTTP_RESOURCE_DEFINE(logo_svg_resource, web_service, "/logo.svg", &logo_svg_resource_detail);

/*
 * Add more static resources following the same pattern:
 * - Images (PNG, JPEG, SVG): image/png, image/jpeg, image/svg+xml
 * - 3D Models (GLTF/GLB): model/gltf-binary
 * - Fonts (WOFF2): font/woff2
 * - JSON data: application/json
 */

/*******************************************************************************
 * Dynamic Resources (REST API Endpoints)
 ******************************************************************************/

/**
 * DYNAMIC RESOURCE PATTERN:
 * 
 * 1. Define data buffer for request/response
 * 2. Define resource detail with callback
 * 3. Register resource with HTTP_RESOURCE_DEFINE()
 * 4. Implement callback function
 * 5. Set callback via setter function
 */

////////////////// POST /api/control (Example: Device Control) //////////////////

static uint8_t control_buf[256];

static struct http_resource_detail_dynamic control_resource_detail = {
	.common = {
		.type = HTTP_RESOURCE_TYPE_DYNAMIC,
		.bitmask_of_supported_http_methods = BIT(HTTP_POST),
		.content_type = "application/json",
	},
	.cb = NULL,  /* Set via http_resources_set_control_handler() */
	.data_buffer = control_buf,
	.data_buffer_len = sizeof(control_buf),
	.user_data = NULL,
};

HTTP_RESOURCE_DEFINE(control_resource, web_service, "/api/control", &control_resource_detail);

/**
 * @brief Set control endpoint handler
 * 
 * Call this from main.c to register your callback function.
 * 
 * @param handler Callback function to handle control requests
 */
void http_resources_set_control_handler(http_resource_dynamic_cb_t handler)
{
	control_resource_detail.cb = handler;
}

////////////////// GET /api/status (Example: Device Status) //////////////////

static uint8_t status_buf[512];

static struct http_resource_detail_dynamic status_resource_detail = {
	.common = {
		.type = HTTP_RESOURCE_TYPE_DYNAMIC,
		.bitmask_of_supported_http_methods = BIT(HTTP_GET),
		.content_type = "application/json",
	},
	.cb = NULL,  /* Set via http_resources_set_status_handler() */
	.data_buffer = status_buf,
	.data_buffer_len = sizeof(status_buf),
	.user_data = NULL,
};

HTTP_RESOURCE_DEFINE(status_resource, web_service, "/api/status", &status_resource_detail);

void http_resources_set_status_handler(http_resource_dynamic_cb_t handler)
{
	status_resource_detail.cb = handler;
}

/*******************************************************************************
 * WebSocket Resource (Real-Time Communication)
 ******************************************************************************/

/**
 * WEBSOCKET PATTERN:
 * 
 * WebSockets enable bidirectional real-time communication.
 * Typical uses: sensor data streaming, live updates, chat
 * 
 * 1. Define context structure for each connection
 * 2. Define resource detail with callback
 * 3. Register resource
 * 4. Implement callback for message handling
 * 5. Use work queue for periodic updates
 */

/* Context for each WebSocket connection */
struct ws_data_ctx {
	int sock;
	struct k_work_delayable work;
	bool active;
};

static struct ws_data_ctx ws_contexts[CONFIG_HTTP_SERVER_MAX_CLIENTS];
static uint8_t ws_data_buffer[128];

static struct http_resource_detail_websocket ws_data_resource_detail = {
	.common = {
		.type = HTTP_RESOURCE_TYPE_WEBSOCKET,
		.bitmask_of_supported_http_methods = BIT(HTTP_GET),  /* Upgrade from GET */
	},
	.cb = NULL,  /* Set via http_resources_set_ws_handler() */
	.data_buffer = ws_data_buffer,
	.data_buffer_len = sizeof(ws_data_buffer),
	.user_data = NULL,
};

HTTP_RESOURCE_DEFINE(ws_data_resource, web_service, "/ws/data", &ws_data_resource_detail);

void http_resources_set_ws_handler(http_resource_websocket_cb_t handler)
{
	ws_data_resource_detail.cb = handler;
}

void http_resources_get_ws_contexts(struct ws_data_ctx **ctx)
{
	*ctx = ws_contexts;
}

/*******************************************************************************
 * Example Callback Implementations
 ******************************************************************************/

/**
 * Example: Control endpoint callback
 * 
 * Receives JSON like: {"led": {"r": 255, "g": 0, "b": 0}}
 * Responds with: {"status": "ok"}
 */
#if 0  /* Remove #if 0 to enable example */
int control_handler(struct http_client_ctx *client, enum http_data_status status,
		    uint8_t *data, size_t len, void *user_data)
{
	if (status == HTTP_SERVER_DATA_FINAL) {
		/* Parse JSON and control device */
		LOG_INF("Received control data: %.*s", len, data);
		
		/* Example: Parse LED control JSON */
		struct led_command cmd;
		int ret = json_obj_parse((char *)data, len, led_command_descr,
					 ARRAY_SIZE(led_command_descr), &cmd);
		if (ret < 0) {
			return ret;
		}
		
		/* Control hardware here */
		LOG_INF("LED: R=%d G=%d B=%d", cmd.r, cmd.g, cmd.b);
		
		/* Send response */
		const char *response = "{\"status\":\"ok\"}";
		return http_server_response_send(client, HTTP_SERVER_STATUS_200_OK,
						 response, strlen(response));
	}
	return 0;
}
#endif

/*******************************************************************************
 * Initialization
 ******************************************************************************/

/**
 * @brief Initialize HTTP resources
 * 
 * Call this early in main() to set up all HTTP resources.
 * Typically called before starting Wi-Fi/network.
 */
void http_resources_init(void)
{
	LOG_INF("HTTP resources initialized");
	LOG_INF("HTTP server will be available at http://<device-ip>:%d", http_service_port);
	LOG_INF("mDNS hostname: %s.local (if enabled)", CONFIG_NET_HOSTNAME);
	
	/* Initialize WebSocket contexts */
	for (int i = 0; i < ARRAY_SIZE(ws_contexts); i++) {
		ws_contexts[i].sock = -1;
		ws_contexts[i].active = false;
	}
}

/*******************************************************************************
 * Usage Example
 ******************************************************************************/

#if 0
/*
 * In main.c:
 * 
 * 1. Define callback functions:
 */
int my_control_handler(struct http_client_ctx *client, 
                       enum http_data_status status,
                       uint8_t *data, size_t len, void *user_data)
{
	/* Handle POST /api/control */
	return 0;
}

int my_status_handler(struct http_client_ctx *client,
                      enum http_data_status status,
                      uint8_t *data, size_t len, void *user_data)
{
	/* Handle GET /api/status */
	const char *status_json = "{\"uptime\":12345,\"temp\":25.5}";
	return http_server_response_send(client, HTTP_SERVER_STATUS_200_OK,
					 status_json, strlen(status_json));
}

/*
 * 2. In main():
 */
void main(void)
{
	/* Initialize HTTP resources */
	http_resources_init();
	
	/* Register callbacks */
	http_resources_set_control_handler(my_control_handler);
	http_resources_set_status_handler(my_status_handler);
	http_resources_set_ws_handler(my_websocket_handler);
	
	/* Start network/Wi-Fi */
	wifi_connect();
	
	/* HTTP server starts automatically when network is up */
}

/*
 * 3. Access web interface:
 *    http://192.168.1.99/              (static HTML page)
 *    http://192.168.1.99/api/status    (dynamic JSON)
 *    ws://192.168.1.99/ws/data         (WebSocket)
 *    http://mydevice.local/            (mDNS if enabled)
 */
#endif
